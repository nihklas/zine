const std = @import("std");

pub const BuildAsset = struct {
    /// Name of this asset
    name: []const u8,
    /// LazyPath of the generated asset.
    ///
    /// The LazyPath cannot be generated by calling `b.path`.
    /// Use the 'assets' directory for non-buildtime assets.
    lp: std.Build.LazyPath,
    /// Installation path relative to the website's asset output path prefix.
    ///
    /// It is recommended to give the file an appropriate file extension.
    /// No need to specify this value if the asset is not meant to be
    /// `link()`ed
    install_path: ?[]const u8 = null,
    /// Installs the asset unconditionally when set to true.
    ///
    /// When set to false, the asset will be installed only if `link()`ed
    /// in a content file or layout (requires `install_path` to be set).
    ///
    /// Note that even when this property is set to false the asset will be
    /// generated by the Zig build system regardless.
    install_always: bool = false,
};

pub const Options = struct {
    /// The directory that contains 'zine.ziggy'.
    /// Defaults to the directory where your 'build.zig' lives.
    website_root: ?std.Build.LazyPath = null,

    /// Assets generated by the Zig build system.
    build_assets: []BuildAsset = &.{},

    /// Path where to install the website, relative to the
    /// zig build install prefix.
    install_path: []const u8 = "",

    /// Debug settings for Zine.
    debug: struct {
        /// The optimization level to use when building Zine.
        optimize: std.builtin.OptimizeMode = .ReleaseFast,

        /// Logging scopes to enable.
        scopes: []const []const u8 = &.{},
    } = .{},
};

/// Builds a Zine website.
pub fn website(project: *std.Build, opts: Options) *std.Build.Step.Run {
    const zine_dep = project.dependencyFromBuildZig(@This(), .{
        .optimize = opts.debug.optimize,
        .scope = opts.debug.scopes,
    });

    const run_zine = project.addRunArtifact(zine_dep.artifact("zine"));
    run_zine.setCwd(opts.website_root orelse project.path("."));
    run_zine.addArg("release");

    const full_install_path = project.pathJoin(&.{
        project.install_prefix,
        opts.install_path,
    });
    run_zine.addArg(project.fmt("--output={s}", .{full_install_path}));

    for (opts.build_assets) |a| {
        run_zine.addArg(project.fmt("--build-asset={s}", .{a.name}));
        run_zine.addFileArg(a.lp);
        if (a.install_always) {
            const out_path = a.install_path orelse std.debug.panic(
                "Build assets '{s}' specifies install_always = true  " ++
                    "but defines no install path.",
                .{a.name},
            );
            run_zine.addArg(project.fmt("--install-always={s}", .{
                out_path,
            }));
        } else if (a.install_path) |ip| {
            run_zine.addArg(project.fmt("--install={s}", .{ip}));
        }
    }

    return run_zine;
}

/// Serves a Zine website via the Zine live server, allowing you to edit
/// the input files and obtaining instant rebuild and page reload.
/// Currently does not support `--watch` but will in the future.
///
/// Ignores `opts.install_path` as it keeps all generated files in memory.
pub fn serve(project: *std.Build, opts: Options) *std.Build.Step.Run {
    const zine_dep = project.dependencyFromBuildZig(@This(), .{
        .optimize = opts.debug.optimize,
        .scope = opts.debug.scopes,
    });

    const run_zine = project.addRunArtifact(zine_dep.artifact("zine"));
    run_zine.setCwd(opts.website_root orelse project.path("."));
    run_zine.addArg("serve");

    for (opts.build_assets) |a| {
        run_zine.addArg(project.fmt("--build-asset={s}", .{a.name}));
        run_zine.addFileArg(a.lp);
        if (a.install_always) {
            const out_path = a.install_path orelse std.debug.panic(
                "Build assets '{s}' specifies install_always = true  " ++
                    "but defines no install path.",
                .{a.name},
            );
            run_zine.addArg(project.fmt("--install-always={s}", .{
                out_path,
            }));
        } else if (a.install_path) |ip| {
            run_zine.addArg(project.fmt("--install={s}", .{ip}));
        }
    }

    return run_zine;
}

pub fn build(b: *std.Build) !void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{
        // .preferred_optimize_mode = .ReleaseFast,
    });

    const tsan = b.option(
        bool,
        "tsan",
        "enable thread sanitizer",
    ) orelse false;

    const enable_tracy = b.option(
        bool,
        "tracy",
        "Enable Tracy profiling",
    ) orelse false;

    const tracy = b.dependency("tracy", .{ .enable = enable_tracy });

    const scopes: []const []const u8 = b.option(
        []const []const u8,
        "scope",
        "logging scopes to enable",
    ) orelse &.{};

    const mode = .{ .target = target, .optimize = optimize };

    const options = blk: {
        const options = b.addOptions();
        const out = options.contents.writer();
        try out.print(
            \\// module = zine
            \\const std = @import("std");
            \\pub const tsan = {};
            \\pub const log_scope_levels: []const std.log.ScopeLevel = &.{{
            \\
        , .{tsan});

        for (scopes) |l| try out.print(
            \\.{{.scope = .{s}, .level = .debug}},
        , std.zig.fmtId(l));
        try out.writeAll("};");
        break :blk options.createModule();
    };

    const scripty = b.dependency("scripty", .{
        .target = target,
        .optimize = optimize,
        .tracy = enable_tracy,
    }).module("scripty");

    const superhtml = b.dependency("superhtml", .{
        .target = target,
        .optimize = optimize,
        .tracy = enable_tracy,
    }).module("superhtml");

    const ziggy = b.dependency("ziggy", mode).module("ziggy");
    const supermd = b.dependency("supermd", .{
        .target = target,
        .optimize = optimize,
        .tracy = enable_tracy,
    }).module("supermd");
    supermd.addImport("scripty", scripty);
    supermd.addImport("superhtml", superhtml);
    supermd.addImport("ziggy", ziggy);

    const zeit = b.dependency("zeit", mode).module("zeit");
    const syntax = b.dependency("flow_syntax", .{
        .target = target,
        .optimize = optimize,
    });
    const ts = syntax.builder.dependency("tree_sitter", mode);
    const treez = ts.module("treez");

    const mime = b.dependency("mime", .{
        .target = target,
        .optimize = optimize,
    });

    // const wuffs = b.dependency("wuffs", mode);

    // const zine = b.addModule("zine", .{
    //     .root_source_file = b.path("src/main.zig"),
    // });
    // zine.addImport("ziggy", ziggy);
    // zine.addImport("scripty", scripty);
    // zine.addImport("supermd", supermd);
    // zine.addImport("superhtml", superhtml);
    // zine.addImport("zeit", zeit);
    // zine.addImport("syntax", syntax.module("syntax"));
    // zine.addImport("treez", treez);

    // setupServer(b, options, target, optimize);

    // const shtml_docgen = b.addExecutable(.{
    //     .name = "shtml_docgen",
    //     .root_source_file = b.path("src/exes/docgen.zig"),
    //     .target = target,
    //     .optimize = .Debug,
    // });
    // shtml_docgen.root_module.addImport("zine", zine);
    // shtml_docgen.root_module.addImport("zeit", zeit);
    // shtml_docgen.root_module.addImport("ziggy", ziggy);
    // b.installArtifact(shtml_docgen);

    if (b.option(
        bool,
        "fuzz",
        "enable building tooling for fuzz testing",
    ) orelse false) {
        setupFuzzing(b, target, optimize);
    }

    // setup the Zine standalone executable
    const zine_exe = b.addExecutable(.{
        .name = "zine",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
        .single_threaded = b.option(
            bool,
            "single-threaded",
            "build Zine in single-threaded mode",
        ) orelse false,

        .sanitize_thread = tsan,
    });

    if (target.result.os.tag == .macos) {
        const frameworks = b.lazyDependency("frameworks", .{}) orelse return;
        zine_exe.addIncludePath(frameworks.path("include"));
        zine_exe.addFrameworkPath(frameworks.path("Frameworks"));
        zine_exe.addLibraryPath(frameworks.path("lib"));
        zine_exe.linkFramework("CoreServices");
    }

    // zine_exe.root_module.addImport("zine", zine);
    zine_exe.root_module.addImport("ziggy", ziggy);
    zine_exe.root_module.addImport("scripty", scripty);
    zine_exe.root_module.addImport("supermd", supermd);
    zine_exe.root_module.addImport("superhtml", superhtml);
    zine_exe.root_module.addImport("zeit", zeit);
    zine_exe.root_module.addImport("syntax", syntax.module("syntax"));
    zine_exe.root_module.addImport("treez", treez);
    zine_exe.root_module.addImport("options", options);
    zine_exe.root_module.addImport("tracy", tracy.module("tracy"));
    zine_exe.root_module.addImport("mime", mime.module("mime"));

    const check = b.step("check", "check the standalone zine executable");
    check.dependOn(&zine_exe.step);
    b.installArtifact(zine_exe);

    const run_step = b.step("run", "run the standalone zine executable");
    const zine_run = b.addRunArtifact(zine_exe);
    zine_run.setCwd(b.path("standalone-test"));
    if (b.args) |args| zine_run.addArgs(args);
    run_step.dependOn(&zine_run.step);

    try setupSnapshotTesting(b, target, zine_exe);
}

fn setupSnapshotTesting(
    b: *std.Build,
    target: std.Build.ResolvedTarget,
    zine_exe: *std.Build.Step.Compile,
) !void {
    const test_step = b.step("test", "build snapshot tests and diff the results");

    const camera = b.addExecutable(.{
        .name = "camera",
        .root_source_file = b.path("build/camera.zig"),
        .target = target,
        .optimize = .ReleaseFast,
    });

    const diff = b.addSystemCommand(&.{
        "git",
        "diff",
        "--cached",
        "--exit-code",
    });
    diff.addDirectoryArg(b.path("tests/"));
    diff.setName("git diff tests/");
    test_step.dependOn(&diff.step);

    // We need to stage all of tests/ in order for untracked files to show up in
    // the diff. It's also not a bad automatism since it avoids the problem of
    // forgetting to stage new snapshot files.
    const git_add = b.addSystemCommand(&.{ "git", "add" });
    git_add.addDirectoryArg(b.path("tests/"));
    git_add.setName("git add tests/");
    diff.step.dependOn(&git_add.step);

    // content scanning
    {
        const tests_dir = try b.build_root.handle.openDir("tests/content-scanning", .{
            .iterate = true,
        });

        var it = tests_dir.iterateAssumeFirstIteration();
        while (try it.next()) |entry| {
            if (entry.kind != .directory) continue;
            if (entry.name[0] == '.') continue;

            const path = b.pathJoin(&.{
                "tests/content-scanning",
                entry.name,
            });

            const run_camera = b.addRunArtifact(camera);
            run_camera.addArtifactArg(zine_exe);
            run_camera.addArg("tree");
            run_camera.setCwd(b.path(path));
            run_camera.has_side_effects = true;

            const out = run_camera.captureStdErr();

            const update_snap = b.addUpdateSourceFiles();
            update_snap.addCopyFileToSource(out, b.pathJoin(&.{ path, "snapshot.txt" }));

            update_snap.step.dependOn(&run_camera.step);
            git_add.step.dependOn(&update_snap.step);
        }
    }

    // rendering
    {
        const tests_dir = try b.build_root.handle.openDir("tests/rendering", .{
            .iterate = true,
        });

        var it = tests_dir.iterateAssumeFirstIteration();
        while (try it.next()) |entry| {
            if (entry.kind != .directory) continue;
            if (entry.name[0] == '.') continue;

            const src_path = b.pathJoin(&.{
                "tests/rendering",
                entry.name,
                "src",
            });
            const out_path = b.pathJoin(&.{ "..", "snapshot" });

            const run_zine = b.addRunArtifact(zine_exe);
            run_zine.addArg("release");
            run_zine.addArg("--output");
            run_zine.addArg(out_path);
            run_zine.setCwd(b.path(src_path));
            run_zine.has_side_effects = true;

            git_add.step.dependOn(&run_zine.step);
        }
    }
}

fn setupFuzzing(
    b: *std.Build,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
) void {
    const afl = b.lazyImport(@This(), "afl_kit") orelse return;

    const scripty_afl_obj = b.addObject(.{
        .name = "scripty",
        .root_source_file = b.path("src/fuzz/scripty.zig"),
        .target = b.resolveTargetQuery(.{}),
        .optimize = .Debug,
    });
    scripty_afl_obj.root_module.stack_check = false;
    scripty_afl_obj.root_module.link_libc = true;

    const afl_exe = afl.addInstrumentedExe(b, target, optimize, scripty_afl_obj);
    b.getInstallStep().dependOn(&b.addInstallFile(afl_exe, "scripty-afl").step);
}
